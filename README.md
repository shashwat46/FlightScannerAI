# Flight Scanner AI

Flight Scanner AI is a full-stack MVP flight discovery platform designed to help users find exceptionally cheap flights. The application leverages multiple data sources, a custom AI-powered scoring algorithm, and generative AI to provide actionable insights, making it easier for users to identify and book the best travel deals.

## Core Features

- **Dynamic Flight Search**: Search for one-way or round-trip flights between specific airports or discover deals from an origin to "anywhere."
- **AI Deal Score**: Every flight is rated on a scale of 0-100, providing an at-a-glance measure of its overall value.
- **AI-Powered Narrative Insights**: Each deal is accompanied by a narrative generated by an LLM, explaining the pros and cons of the flight and destination.
- **Price History & Analysis**: Deal detail pages feature historical price quartiles to give users context on the current fare.
- **Advanced Filtering**: Filter results by number of stops, trip type, number of travelers, and cabin class.

## Architecture & System Design

This project is built as a monolithic full-stack application using **Next.js**, which allows for rapid development and tight integration between the frontend and backend.

### Tech Stack

- **Framework**: Next.js (App Router)
- **Language**: TypeScript
- **Styling**: CSS Modules & Tailwind CSS utility classes
- **Database**: Supabase (Postgres) for storing airline/airport quality ratings.
- **Caching**: Redis for caching API responses from flight data providers.
- **Flight Data Providers**: Amadeus & SerpApi (Google Flights)
- **AI Narrative Generation**: Perplexity AI

### System Diagram

#### Backend Architecture

The backend is built using **Next.js API Routes**. It follows a service-oriented pattern to separate concerns and abstract away data provider specifics.

1. **API Layer (app/api/*)**: Handles incoming HTTP requests, performs validation using Zod, and calls the appropriate services.
2. **Service Layer (src/services/*)**: Contains the core business logic. For example, `SearchService.ts` orchestrates the process of fetching, caching, and scoring flight offers.
3. **Provider Layer (src/providers/*)**: An abstraction layer for third-party APIs. Each provider (e.g., `AmadeusProvider.ts`, `GoogleFlightsProvider.ts`) implements a common `SearchProvider` interface. This makes it easy to add, remove, or switch between data sources without changing the core business logic.
4. **Caching**: A Redis client is used to cache responses from flight data providers. This is crucial for reducing latency on subsequent identical searches and minimizing API costs.

### Data Sourcing Strategy

A multi-provider strategy was chosen to ensure data redundancy and leverage the unique strengths of different APIs.

- **SerpApi (Google Flights)**: This is the primary provider due to its high-quality, real-time data and comprehensive coverage, which mirrors what users see on Google Flights. It's particularly effective for getting live booking options.
- **Amadeus**: A powerful GDS (Global Distribution System) provider, Amadeus is used for its robust "Flight Inspiration" and "Cheapest Date" search functionalities, perfect for "anywhere" searches and discovering deals without fixed dates.
- **Perplexity AI**: Used to generate the "AI Insights" narrative. A detailed prompt is constructed with structured data about the flight (price, airline quality, stops, etc.), and the LLM returns a JSON object containing a concise analysis.
- **Supabase (Postgres)**: Static data, such as Skytrax airline and airport quality ratings, is stored in a Postgres database managed by Supabase. This data is used as a key input for the AI Deal Score.

### AI Deal Score Logic

The AI Deal Score is a weighted algorithm that assesses multiple factors to produce a single, easy-to-understand score.

- **Price vs. Median (40% weight)**: Compares the current flight price against historical data for that route.
- **Duration Penalty (15% weight)**: Penalizes excessively long flight durations.
- **Stop Penalty (15% weight)**: Direct flights score highest; scores decrease with each additional stop.
- **Airline & Airport Quality (15% weight)**: Uses Skytrax ratings stored in our database.
- **Layover Quality (10% weight)**: Considers the length and convenience of layovers.
- **Other Factors (5%)**: Includes baggage allowance and confidence in the data.

The weights are normalized and can be easily tuned in `src/config/score.ts` to adjust the scoring model.

## Future Plans & Scalability Roadmap

The current MVP provides a solid foundation. The following steps outline a roadmap to evolve it into a production-grade, scalable application.

### Phase 1: User Personalization & Proactive Search

- **Authentication**:
  - **Implementation**: Integrate Supabase Auth to add user accounts with social login (Google, etc.) and email/password options.
  - **Benefit**: This is the foundation for all personalized features.

- **Saved Searches & Price Alerts**:
  - **Implementation**: Allow authenticated users to save their frequent searches (e.g., "NYC to LON in June"). A CRON job will run daily or hourly to execute these saved searches in the background.
  - **Benefit**: Moves the application from a purely reactive model (user must search) to a proactive one (app finds deals for the user).

### Phase 2: Building a Scalable Background Processing System

- **Message Queues (e.g., RabbitMQ, AWS SQS)**:
  - **Implementation**: Instead of CRON jobs directly performing the searches, they will add "search tasks" to a message queue. A separate fleet of scalable worker services will consume tasks from this queue, fetch data from flight APIs, score the results, and store them.
  - **Benefit**: Decouples task scheduling from task execution. This is highly scalable and resilient; if an API call fails, the task can be retried. We can easily scale the number of workers up or down based on load.

- **Historical Pricing Database**:
  - **Implementation**: The worker services will store all retrieved flight data in a time-series database (e.g., TimescaleDB) or a structured Postgres table.
  - **Benefit**: This creates a rich historical dataset, which is critical for making the "Price vs. Median" component of the AI Deal Score far more accurate. It removes the reliance on real-time, limited historical data from APIs.

### Phase 3: Production Hardening

- **API Security**:
  - **Implementation**: Add rate limiting to all public API endpoints to prevent abuse. Implement authentication checks to protect user-specific endpoints.

- **Containerization & Deployment**:
  - **Implementation**: Containerize the application using Docker for consistent development and deployment environments. Set up a CI/CD pipeline for automated testing and deployment.

- **Comprehensive Testing**:
  - **Implementation**: Introduce a full testing suite, including unit tests for services and scoring logic, integration tests for API routes, and end-to-end tests for critical user flows.
